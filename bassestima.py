# -*- coding: utf-8 -*-from __future__ import divisionfrom math import e,logfrom scipy import statsimport sympy as syimport pylab as plimport numpy as npimport pandas as pdimport timeimport copydef sample(para_range,count):    a = (para_range[0][1]-para_range[0][0])*np.random.random(count) + para_range[0][0]    b = (para_range[1][1]-para_range[1][0])*np.random.random(count) + para_range[1][0]    c = np.random.randint(low = para_range[2][0],high=para_range[2][1]+1,size=count)    d = np.array([a,b,c]).T    return d.tolist()def bass_diffuse(p,q,m,t):    a = 1 - e**(-(p+q)*t)    b = 1 + q/p*e**(-(p+q)*t)    return m*a/bdef estimation(indiv,len_actual):    diffu_cont = np.zeros(len_actual)    t_list = np.arange(1,len_actual+1)    a = np.array([1 - e**(-(indiv[0]+indiv[1])*t) for t in t_list])    b = np.array([1 + indiv[1]/indiv[0]*e**(-(indiv[0]+indiv[1])*t) for t in t_list])    diffu_cont = indiv[2]*a/b            adopt_cont = np.zeros_like(diffu_cont)    adopt_cont[0] = diffu_cont[0]    for t in xrange(1,len_actual):        adopt_cont[t] = diffu_cont[t] - diffu_cont[t-1]        return adopt_contdef sse(indiv,s_actual):                                               #定义适应度函数（sse）    a = estimation(indiv,len(s_actual))    s_actual = np.array(s_actual)    tse = np.square(s_actual-a)    return np.mean(tse)    def repete_estim(s_act,para_range,t_n=500,c_n=50,s_threshold=1e-6,repetes=1):    solution_cont = []    orig_points = [[x,y,z] for x in para_range[0] for y in para_range[1] for z in para_range[2]]        for i in xrange(repetes):        c_range = copy.deepcopy(para_range)        samp = sample(para_range,t_n)        graded = sorted([sse(x,s_act)]+x for x in samp+orig_points)        solution = graded[:c_n]        while 1:            a_min = np.min(np.array(solution),0)            b_max = np.max(np.array(solution),0)            for j in xrange(3):                c_range[j][0] = a_min[j+1]                c_range[j][1] = b_max[j+1]            samp = sample(c_range,t_n)            solution = sorted([[sse(x,s_act)]+x for x in samp]+solution)[:c_n]                                                   r = sorted([x[0] for x in solution])            v = (r[c_n-1]-r[0])/r[0]                if v < s_threshold:                        break                        solution_cont.append(solution[0])        solution = np.array(solution_cont)    M_sse,M_p,M_q,M_m = np.median(solution,axis=0)    M_sse = sse([M_p,M_q,M_m],s_act)        return M_sse,M_p,M_q,M_m,solution    def cal_R_sigma(indiv,s_actual):    a = estimation(indiv,len(s_actual))    s_actual = np.array(s_actual)    sse = np.sum(np.square(s_actual-a))    ave_y = np.mean(s_actual)    ssl = np.sum(np.square(s_actual-ave_y))    R_2 = (ssl-sse)/ssl    sigma = np.sqrt(sse/(len(s_actual)-len(indiv)))        return R_2,sigma    def estim_param_var(f_param,sigma,len_actual):    p,q,m = sy.symbols('p q m')    expr = m*(1 - e**-(p+q))/(1 + q/p*e**-(p+q))    expr_dr_p_2 = sy.diff(expr,p)**2    expr_dr_p_q = sy.diff(expr,p)*sy.diff(expr,q)    expr_dr_p_m = sy.diff(expr,p)*sy.diff(expr,m)          expr_dr_q_2 = sy.diff(expr,q)**2    expr_dr_q_m = sy.diff(expr,q)*sy.diff(expr,m)        expr_dr_m_2 = sy.diff(expr,m)**2        for i in range(1,len_actual):        expr_i = m*(1 - e**(-(p+q)*(i+1)))/(1 + q/p*e**(-(p+q)*(i+1)))- m*(1 - e**(-(p+q)*i))/(1 + q/p*e**(-(p+q)*i))        expr_dr_p_2 += sy.diff(expr_i,p)**2        expr_dr_p_q += sy.diff(expr_i,p)*sy.diff(expr_i,q)        expr_dr_p_m += sy.diff(expr_i,p)*sy.diff(expr_i,m)                expr_dr_q_2 += sy.diff(expr_i,q)**2        expr_dr_q_m += sy.diff(expr_i,q)*sy.diff(expr_i,m)                expr_dr_m_2 += sy.diff(expr_i,m)**2            matrix_to_return = [[expr_dr_p_2,expr_dr_p_q,expr_dr_p_m],                        [expr_dr_p_q,expr_dr_q_2,expr_dr_q_m],                        [expr_dr_p_m,expr_dr_q_m,expr_dr_m_2]]        var_matrix = np.zeros((3,3))    for i in range(3):        for j in range(3):            var_matrix[i][j] = matrix_to_return[i][j].subs([(p,f_param[0]),(q,f_param[1]),(m,f_param[2])])                var_matrix = np.matrix(var_matrix)    var_covar_matrix = np.sqrt(sigma**2*abs(var_matrix.getI()))        return var_covar_matrix    def signf_test(param_set,sigma,len_actual):    result_cont = []    num_free = len_actual - len(param_set)    for prmt in param_set:        t_value = prmt[0]/prmt[1]        pval_prmt = stats.t.sf(np.abs(t_value),num_free)*2        if pval_prmt <= 0.001:            prmt_cont = (t_value,pval_prmt,'***')        elif pval_prmt <= 0.01:            prmt_cont = (t_value,pval_prmt,'**')        elif pval_prmt <= 0.01:            prmt_cont = (t_value,pval_prmt,'*')        else:            prmt_cont = (t_value,pval_prmt,' ')                result_cont.append(prmt_cont)        return result_cont    def pred_one_step(s_act,para_range):    solution = repete_estim(s_act,para_range,t_n= 500,c_n= 50,s_threshold=1e-8)       Esse,p,q,m = solution      peak_time = int(np.floor(log(q/p)/(p+q)))        pre_peak = []        for i in range(3,peak_time):        s_act_i = s_act[:i]        solution = repete_estim(s_act_i,para_range,t_n= 500,c_n= 50,s_threshold=1e-8,repetes=1)           Esse,p,q,m = solution        s_i = m*(1 - e**(-(p+q)*(i+1)))/(1 + q/p*e**(-(p+q)*(i+1))) - m*(1 - e**(-(p+q)*i))/(1 + q/p*e**(-(p+q)*i))        abs_sale = abs(s_i - s_act[i])        pre_peak.append(abs_sale)        MAD1 = np.mean(pre_peak)        post_peak = []    for i in range(peak_time,len(s_act)-1):        s_act_i = s_act[:i]        solution = repete_estim(s_act_i,para_range,t_n= 500,c_n= 50,s_threshold=1e-8,repetes=1)           Esse,p,q,m = solution        s_i = m*(1 - e**(-(p+q)*(i+1)))/(1 + q/p*e**(-(p+q)*(i+1))) - m*(1 - e**(-(p+q)*i))/(1 + q/p*e**(-(p+q)*i))        abs_sale = abs(s_i - s_act[i])        post_peak.append(abs_sale)       MAD2 = np.mean(post_peak)        return MAD1,MAD2   def fit_it(s_act,para_range,t_n= 500,c_n= 100,s_threshold=1e-10,repetes=1,summary = 0):        time1 = time.clock()    len_actual = len(s_act) #销售数据数量        solution = repete_estim(s_act,para_range,t_n= 500,c_n= 100,s_threshold=1e-10,repetes=1)       Esse,p,q,m,d_cont = solution        F_solution = [p,q,m] #参数估计值    R2,sigma = cal_R_sigma(F_solution,s_act) #R方和标准误    v_cov_mat = np.array(estim_param_var(F_solution,sigma,len_actual))  #参数协方差矩阵    var_param = [v_cov_mat[0][0],v_cov_mat[1][1],v_cov_mat[2][2]]  #参数p,q,m的标准方差    est_param = zip(F_solution,var_param)    t_test = signf_test(est_param,sigma,len_actual)        to_print = {'Parameters':F_solution,'Std.Error':var_param,'t_value':[t_test[i][0] for i in range(3)],            'prob':[t_test[i][1] for i in range(3)],'signf':[t_test[i][2] for i in range(3)]}    to_print = pd.DataFrame(to_print,index=['p','q','m'])        if summary == 1:        print 'Time elapsed:',time.clock()-time1,'s'        print '----------------------------------------------------------------'        print to_print        print '----------------------------------------------------------------'        print 'Signif. codes:  p <= 0.001 ***, p <= 0.01 **, p <= 0.05 *'        print 'Residual standard error:',sigma,'on',len(s_act)-len(F_solution),'degrees of freedom'        print 'Residual:',Esse        print 'Explained by variables:',R2        return to_print,Esse,R2                        def draw_it(F_solution,len_actual,s_act):    e_sale = estimation(F_solution,len_actual)    error_series = s_act - e_sale        fig = pl.figure(figsize=(9,9))    ax1 = fig.add_subplot(2,1,1)    ax1.plot(np.arange(1,len_actual+1),s_act,'ys--',label=r'$actual$')    ax1.plot(np.arange(1,len_actual+1),e_sale,'r-',linewidth = 1.2,label=r'$fitted$')    ax1.set_title(r'Fitted and actual curve',fontsize=18)    ax1.set_xlabel(r'time',fontsize=15)    ax1.set_ylabel(r'Sales',fontsize=15)    ax1.set_xlim([1,len_actual])    ax1.legend(loc = 'best')    ax1.grid(True)        ax2 = fig.add_subplot(2,1,2)    ax2.plot(np.arange(1,len_actual+1),error_series,'r^--')    ax2.plot(np.arange(1,len_actual+1),np.zeros(len_actual),'k--')    ax2.set_title(r'Error',fontsize=18)    ax2.set_xlabel(r'time',fontsize=15)    ax2.set_ylabel(r'Residuals',fontsize=15)    ax2.set_xlim([1,len_actual])    ax2.grid(True)        pl.tight_layout()